#!/usr/bin/env python
# manage_gitignore.py
"""
Safely manage .gitignore entries without duplicates or data loss.
Works on Linux, macOS, and Windows (including Git Bash).
"""

import sys
import logging
import subprocess
import platform
from pathlib import Path
from typing import List, Optional, Set

import chardet

# Configure logging
logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class GitIgnoreManager:
    DEFAULT_ENTRIES ="""# Default .gitignore entries for Python projects
############################
# ðŸ PYTHON BYTECODE FILES
# Avoid tracking compiled Python artifacts
############################
__pycache__/
**/__pycache__/
*.py[cod]
*$py.class

############################
# ðŸ“¦ VIRTUAL ENVIRONMENTS
# Don't include local virtualenvs (by name or location)
############################
env/
venv/
.venv/
ENV/
**/env/
**/venv/
**/.venv/

############################
# ðŸ§ª TEST OUTPUT & COVERAGE
# Ignore test artifacts, reports, and caches
############################
*.log
*.coverage
.coverage
htmlcov/
.cache/
.tox/
.nox/
.pytest_cache/

############################
# ðŸ—ï¸ BUILD / DISTRIBUTION FILES
# Python packaging outputs and build folders
############################
build/
dist/
*.egg
*.egg-info/
.eggs/

############################
# ðŸ’» IDE / EDITOR SETTINGS
# Editor-specific configs that shouldn't be shared
############################
.vscode/
.idea/
*.swp
*.swo

############################
# ðŸ”’ ENVIRONMENT VARIABLES / SECRETS
# Protect secrets and local environment configs
############################
.env
.env.*
**/.env
**/.env.*
!.env.example  # allow safe template files

############################
# ðŸ³ DOCKER / RUNTIME SOCKETS & PIDs
# Runtime process or socket files (useful for container setups)
############################
*.pid
*.sock

############################
# ðŸ““ JUPYTER NOTEBOOK FILES
# Jupyter auto-saved checkpoint files
############################
.ipynb_checkpoints/

############################
# ðŸ–¥ï¸ OS-SPECIFIC FILES
# Files generated by macOS and Windows
############################
.DS_Store
Thumbs.db

############################
# ðŸ“ GIT COMMIT DRAFTS / CUSTOM LOGS
# Allow local commit drafts while excluding generated logs
############################
commit-*
**/commit-*
!docs/commit-examples/commit-*
!docs/commit-logs/
!docs/commit-logs/**

############################
# ðŸ—‚ï¸ MISCELLANEOUS 
# Other common patterns that may be useful
# You can add your own here as needed
############################
"""

    def __init__(self, repo_path: Path):
        self.repo_path = repo_path
        self.gitignore_path = repo_path / ".gitignore"
        self.existing_patterns: Set[str] = set()
        self.existing_content: List[str] = []

    def is_valid_utf8(self, raw: bytes) -> bool:
        try:
            raw.decode("utf-8")
            return True
        except UnicodeDecodeError:
            return False

    def detect_file_encoding(self) -> Optional[str]:
        """Use `file` CLI to detect encoding (if available)."""
        if platform.system() == "Windows":
            return None
        try:
            result = subprocess.run(
                ["file", "--brief", "--mime-encoding", str(self.gitignore_path)],
                capture_output=True,
                text=True,
                check=True,
            )
            return result.stdout.strip()
        except Exception:
            return None

    def read_gitignore_safely(self) -> List[str]:
        """Read .gitignore with strong validation and detection."""
        raw = self.gitignore_path.read_bytes()

        # Step 1: Validate UTF-8 first
        if self.is_valid_utf8(raw):
            logger.info("âœ… .gitignore is valid UTF-8")
            return raw.decode("utf-8").splitlines(keepends=True)

        # Step 2: Use chardet
        result = chardet.detect(raw)
        detected_encoding = result["encoding"]
        confidence = result["confidence"]
        logger.info(f"ðŸ” Detected encoding: {detected_encoding} (confidence: {confidence:.2f})")

        # Step 3: Validate against `file` CLI
        system_detected = self.detect_file_encoding()
        if system_detected:
            logger.warning(f"ðŸ’¡ 'file' tool reports encoding: {system_detected}")
            if "utf" not in system_detected.lower():
                logger.error("âŒ .gitignore is not UTF-8. Please convert it manually.")
                raise ValueError("Aborting to prevent corrupting a non-UTF-8 file.")

        # Step 4: Try decoding with chardet guess
        try:
            return raw.decode(detected_encoding).splitlines(keepends=True)
        except Exception as e:
            logger.error(f"âŒ Could not decode .gitignore: {e}")
            raise ValueError("Please manually convert .gitignore to UTF-8.")

    def load_existing_gitignore(self) -> None:
        if not self.gitignore_path.exists():
            logger.info("No existing .gitignore found")
            return

        self.existing_content = self.read_gitignore_safely()
        for line in self.existing_content:
            stripped = line.strip()
            if stripped and not stripped.startswith("#"):
                self.existing_patterns.add(stripped)
        logger.info(f"Loaded {len(self.existing_patterns)} existing patterns from .gitignore")

    def patterns_equivalent(self, pattern1: str, pattern2: str) -> bool:
        return pattern1.strip("/").lstrip("**/") == pattern2.strip("/").lstrip("**/")

    def pattern_exists(self, pattern: str) -> bool:
        pattern = pattern.strip()
        if pattern in self.existing_patterns:
            return True
        return any(self.patterns_equivalent(pattern, existing) for existing in self.existing_patterns)

    def write_gitignore(self, new_patterns: List[str]) -> None:
        """Write updated content to .gitignore without extra blank lines."""
        existing_text = ""
        if self.gitignore_path.exists():
            existing_text = self.gitignore_path.read_text(encoding="utf-8").rstrip()
    
        new_text = "\n".join(new_patterns).strip()
    
        # Merge with two newlines between existing and new content if both exist
        if existing_text and new_text:
            combined = f"{existing_text}\n\n{new_text}\n"
        elif new_text:
            combined = f"{new_text}\n"
        else:
            combined = f"{existing_text}\n"
    
        with open(self.gitignore_path, "w", encoding="utf-8", newline="\n") as f:
            f.write(combined)
    
        logger.info(f"âœ… Updated {self.gitignore_path}")


    def add_entries(self, entries: Optional[str] = None) -> int:
        if entries is None:
            entries = self.DEFAULT_ENTRIES

        self.load_existing_gitignore()
        new_lines = entries.strip().split("\n")
        patterns_to_add = []
        current_section = []
        added_count = 0

        for line in new_lines:
            stripped = line.strip()
            if not stripped:
                if current_section and any(p[1] for p in current_section):
                    patterns_to_add.append("")
                continue

            if stripped.startswith("#"):
                current_section.append((line, False))
                continue

            if not self.pattern_exists(stripped):
                current_section.append((line, True))
                added_count += 1
                logger.info(f"âœ… Will add: {stripped}")
            else:
                logger.debug(f"â­ï¸ Skipped duplicate: {stripped}")
                current_section.append((line, False))

        if current_section and any(p[1] for p in current_section):
            for line, _ in current_section:
                patterns_to_add.append(line)

        if added_count > 0:
            self.write_gitignore(patterns_to_add)
        else:
            logger.info("âœ… All patterns already exist. Nothing to add.")

        return added_count

    def list_patterns(self) -> List[str]:
        self.load_existing_gitignore()
        return sorted(self.existing_patterns)


def update_gitignore(repo_path: Path, entries: Optional[str] = None) -> bool:
    try:
        manager = GitIgnoreManager(repo_path)
        added = manager.add_entries(entries)
        return added > 0
    except Exception as e:
        logger.error(f"Failed to update .gitignore: {e}")
        return False


def main():
    import argparse

    parser = argparse.ArgumentParser(description="Manage .gitignore entries safely")
    parser.add_argument("repo_path", type=str, help="Path to the repository")
    parser.add_argument("--custom-entries", type=str, help="Path to custom patterns")
    parser.add_argument("--list", action="store_true", help="List current patterns")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")

    args = parser.parse_args()

    if args.debug:
        logger.setLevel(logging.DEBUG)

    repo_path = Path(args.repo_path).resolve()
    if not repo_path.exists():
        logger.error(f"Repository path does not exist: {repo_path}")
        sys.exit(1)

    manager = GitIgnoreManager(repo_path)

    if args.list:
        patterns = manager.list_patterns()
        print(f"\nCurrent .gitignore patterns ({len(patterns)}):")
        for p in patterns:
            print(f"  {p}")
        sys.exit(0)

    entries = None
    if args.custom_entries:
        with open(args.custom_entries, "r", encoding="utf-8") as f:
            entries = f.read()

    added = manager.add_entries(entries)
    sys.exit(0 if added >= 0 else 1)


if __name__ == "__main__":
    main()
